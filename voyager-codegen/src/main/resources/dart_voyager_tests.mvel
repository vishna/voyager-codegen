/// Generated file, DO NOT EDIT
import 'package:flutter/widgets.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:meta/meta.dart';
import 'package:test_api/test_api.dart' as test_package;
import 'package:voyager/voyager.dart';

typedef WidgetWrapper = Widget Function(Widget nonWrappedWidget);

@isTest
void _testVoyagerWidget(
  String description,
  Future<RouterNG> routerFuture,
  WidgetWrapper widgetWrapper,
  @{baseScenarioClassName} scenario, {
  bool skip = false,
  test_package.Timeout timeout,
  Duration initialTimeout,
  bool semanticsEnabled = false,
}) {
  testWidgets(description, (WidgetTester tester) async {
    await tester.runAsync(() async {
      final router = await routerFuture;

      expect(router, isInstanceOf<RouterNG>());

      VoyagerArgument argument;

      if (scenario.argument != null) {
        if (scenario.argument is VoyagerArgument) {
          argument = scenario.argument;
        } else {
          argument = VoyagerArgument(scenario.argument);
        }
      }

      var widget = scenario.argument == null
          ? VoyagerWidget(path: scenario.path(), router: router)
          : VoyagerStatelessWidget(
              path: scenario.path(), router: router, argument: argument, useCache: true);
      widget = widgetWrapper != null ? widgetWrapper(widget) : widget;
      widget = scenario.widgetWrapper != null ? scenario.widgetWrapper(widget) : widget;

      await tester.pumpWidget(widget);

      scenario.widgetTesterCallback(tester);
    });
  },
      skip: skip,
      timeout: timeout,
      initialTimeout: initialTimeout,
      semanticsEnabled: semanticsEnabled);
}

@experimental
abstract class @{baseScenarioClassName} {
  @{baseScenarioClassName}(this.testDescription, this.widgetTesterCallback, {this.argument});

  final String testDescription;
  final WidgetTesterCallback widgetTesterCallback;
  final dynamic argument;
  WidgetWrapper widgetWrapper;

  String path();
  void addWidgetWrapper(WidgetWrapper widgetWrapper) {
    this.widgetWrapper = widgetWrapper;
  }
}

@foreach{scenarioClass : scenarioClasses}@{resolver.emit(scenarioClass)}@end{}

@experimental
abstract class @{baseScenarioClassName}s {
  const @{baseScenarioClassName}s(this.defaultWrapper);
  final WidgetWrapper defaultWrapper;

  @foreach{scenarioClass : scenarioClasses}List<@{scenarioClass.scenarioClassName}> @{scenarioClass.type()}Scenarios();@end{'\n'}
}

@isTestGroup @experimental
void @{name}AutomatedTests(String description, Future<RouterNG> router,
    @{baseScenarioClassName}s testScenarios, {bool forceTests = true}) {
  group(description, () {

@foreach{scenarioClass : scenarioClasses}@{resolver.emitAsExecutionBlock(scenarioClass)}@end{'\n'}

  });
}