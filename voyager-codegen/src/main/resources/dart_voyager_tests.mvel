/// Generated file, DO NOT EDIT
import 'package:flutter/widgets.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:meta/meta.dart';
import 'package:test_api/test_api.dart' as test_package;
import 'package:voyager/voyager.dart';

typedef WidgetWrapper<T extends @{baseScenarioClassName}s> = Widget Function(Widget nonWrappedWidget, Router router, T scenarios);

@isTest
void _testVoyagerWidget<T extends @{baseScenarioClassName}s>(
  String description,
  Future<Router> routerFuture,
  WidgetWrapper widgetWrapper,
  T scenarios,
  @{baseScenarioClassName} scenario, {
  bool skip = false,
  test_package.Timeout timeout,
  Duration initialTimeout,
  bool semanticsEnabled = false,
}) {
  testWidgets(description, (WidgetTester tester) async {
    Router router;
    await tester.runAsync(() async {
      router = await routerFuture;
      expect(router, isNotNull);
    });

    VoyagerArgument argument;

    if (scenario.argument != null) {
      if (scenario.argument is VoyagerArgument) {
        argument = scenario.argument;
      } else {
        argument = VoyagerArgument(scenario.argument);
      }
    }

    var widget = scenario.stateless == false
        ? VoyagerWidget(path: scenario.path(), router: router, argument: argument)
        : VoyagerStatelessWidget(
            path: scenario.path(),
            router: router,
            argument: argument,
            useCache: true);
    widget = widgetWrapper != null
        ? widgetWrapper(widget, router, scenarios)
        : widget;
    widget = scenario.widgetWrapper != null
        ? scenario.widgetWrapper(widget, router, scenarios)
        : widget;

    await tester.pumpWidget(widget);
    await scenario.widgetTesterCallback(tester);
  },
      skip: skip,
      timeout: timeout,
      initialTimeout: initialTimeout,
      semanticsEnabled: semanticsEnabled);
}

@experimental
abstract class @{baseScenarioClassName} {
  @{baseScenarioClassName}(this.testDescription, this.widgetTesterCallback, {this.argument, this.stateless = false});

  final String testDescription;
  final WidgetTesterCallback widgetTesterCallback;
  final dynamic argument;
  final bool stateless;
  WidgetWrapper widgetWrapper;

  String path();
  void addWidgetWrapper(WidgetWrapper widgetWrapper) {
    this.widgetWrapper = widgetWrapper;
  }
}

@foreach{scenarioClass : scenarioClasses}@{resolver.emit(scenarioClass)}@end{}

@experimental
abstract class @{baseScenarioClassName}s {
  const @{baseScenarioClassName}s(this.defaultWrapper);
  final WidgetWrapper defaultWrapper;

  @foreach{scenarioClass : scenarioClasses}List<@{scenarioClass.scenarioClassName}> @{scenarioClass.type()}Scenarios();@end{'\n'}
}

@isTestGroup @experimental
void @{name}AutomatedTests<T extends @{baseScenarioClassName}s>(String description, Future<Router> router,
    @{baseScenarioClassName}s testScenarios, {bool forceTests = true}) {
  group(description, () {

@foreach{scenarioClass : scenarioClasses}@{resolver.emitAsExecutionBlock(scenarioClass)}@end{'\n'}

  });
}